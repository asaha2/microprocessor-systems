%-------------------------------------------------
\subsection{Serial Peripheral Interface}
Serial Peripheral Interface (SPI) is a synchronous serial communication interface bus commonly used to send data between microcontrollers and small peripherals. SPI devices communicate in full-duplex mode using a master-slave architecture with a single master. Communication frame is initiated by the master for reading and writing -- multiple slave devices are supported through selection with individual select lines. 

The SPI protocol defines 4 signal wires for transmission:
\begin{itemize}
\item Master Out Slave In (MOSI) - MOSI signal is generated by the master with slave as the recipient
\item Master In Slave Out (MISO) - Slaves generate MISO signal with master as the intended recipient
\item Serial Clock (SCK) - SCK is the serial clock signal generated by the master to synchronize the data transfers between the nodes
\item Slave Select (SS) - SS signal is generated by the master to select individual slave devices; the SS is an active low signal
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[scale = 0.8]{single_spi.png}
\textit{\caption{SPI bus with single master and single slave}\label{fig:single_spi}}
\end{figure}

Communication is always initiated by the master. The master initially configures the bus clock to set the baud rate for data transmission; and subsequently selects a particular slave device by pulling the SS line corresponding to that device to 'low' state. Following initial configuration a full duplex data transmission can occur during each clock cycle -- the master sends a bit and the slave receives it on the MOSI line simultaneously. The slave may also send a bit on the MISO line for the master to read. Data transmission is organized by using shift registers with a defined word size (8-bits in our case) in both master and slave devices. Data is shifted out with MSB first, while shifting in a new LSB into the same register. The process is repeated until data transmission has completed. Notably in the event that the slave intends to send data, the master must first send dummy bytes to the slave. This results in clocking the bus and subsequently the data sent out by the slave is received by the master simultaneously. 

\begin{figure}[!ht]
\centering
\includegraphics[scale = 0.5]{shift_spi.png}
\textit{\caption{Hardware setup using two shift registers for inter-chip circular buffer}\label{fig:shift_spi}}
\end{figure}

%-------------------------------------------------
\subsection{Pulse Width Modulation}
Pulse Width Modulation (PWM) is a technique for supplying electrical power to a load that has a relatively slow electro-mechanical response. The supply signal consists of a train of voltage pulses such that the width of the individual pulse controls the effective voltage level at the load. This modulation technique is usually applied in embedded systems to fine tune the effective output voltage at the attached peripheral devices. 

The PWM pulse train acts like a DC signal when devices that receive the signal have an electro-mechanical response time that is slower than the frequency of the pulses. The peripheral device essentially smooths out the energy bursts delivered by the input PWM pulses such that lesser or greater electrical power is output depending on the width of the pulses. For an LED peripheral, PWM causes the light to be turned on and off at frequencies that the light is only perceivable by the human eye to be brighter or dimmer depending on the width of the pulses. 

The equation \ref{eq:pwm} may be considered during the calculation of effective output voltage while considering signal pulses of duration $\tau_{o}$ that repeats every $\tau_{c}$ units of time. $V_{s}$ is the maximum output voltage of the PWM channel. The ratio $\frac{\tau_{o}}{\tau_{c}}$ is called the duty cycle of the wave pulses. The effective output voltage is controlled by adjusting the duty cycle of the PWM pulses. The above discussion may be complemented with figure \ref{fig:pwm} for clarity.

\begin{equation}
\label{eq:pwm}
V_{eff} = V_{s} \frac{\tau_{o}}{\tau_{c}}
\end{equation}

\begin{figure}[!ht]
 \centering
 \includegraphics[scale = 0.8]{pwm.PNG}
\textit{\caption{Definition of PWM duty cycle}\label{fig:pwm}}
\end{figure}

%-------------------------------------------------
\subsection{SPI Configuration for Inter-board Communication}
SPI protocol has been implemented to accomplish communication between the Nucleo and the Discovery board. For the application in discussion the Nucleo board has been chosen as the master and the Discovery board chosen to be the slave. Initial configuration involved selection of appropriate pins and specification of pin characteristics for the intended MISO, MOSI, SCK and SS lines for both the master and slave devices. For operations specific to SPI, the clock and the data lines have been configured as alternate function push-pull with appropriate SPI peripheral specified in each case (SPI2 for both master and slave). The select line is configured to be active low. The active push-pull configuration is dependent on the role of the node in the communication network and the communication line in consideration. Table \ref{table:pin_config} may be referred to for breakdown of these GPIO configurations. 

\begin{table}[!htbp]
\centering
\caption{SPI pin configuration -- Function and Push-pull state}
\label{table:pin_config}
\begin{tabular}{|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
\hline
       & SCK                  & MISO                & MOSI                & SS              & INT                  \\ \hline
Master & Alternate - No pull  & Alternate - No pull & Alternate - No pull & Output - Pullup & Output - No pull     \\ \hline
Slave  & Alternate - Pulldown & Alternate - No pull & Alternate - No pull & Input - Pullup  & IT rising - Pulldown \\ \hline
\end{tabular}
\end{table}

For the final demo version another GPIO pin has been configured to sample pushbutton clicks produced on the Nucleo board. The intended action was to increment the LED brightness on the Discovery board, hence an interrupt line has also been introduced between the boards. This interrupt line is intended to synchronize SPI write events from the master to the slave once pushbutton click has been registered. 

Following GPIO pin configurations, peripheral specific configurations have been defined. Some of the key configurations are discussed in following.
\begin{itemize}
\item SPI Peripheral - SPI2 has been configured as the intended SPI peripheral in both master and slave devices. Notably, SPI1 peripheral on the master has been used to interface with the bluetooth shield and the same on slave device has been used to interface with the MEMS accelerometer.
\item Baud Rate - The baud rate for data transmission is defined by the master by means of a prescaler value. In the case of our application a prescaler value of 128 has been defined. This value has been determined following extensive SPI transmission tests and subsequent data integrity checks.
\item Direction - A full duplex configuration has been chosen for the defined SPI communication, such that simultaneous bi-directional read and write can be performed.
\item Clock Phase and Polarity - These parameters determine the edges of the clock signal on which the data are driven and sampled. In the case of our application only 1 phase has been defined with low base polarity -- hence the clock polarity has been defined as active high (base polarity defined as 'LOW') with the data being sampled only on the rising edge.
\item CRC - Cyclic Redundancy Check is a technique to verify data transmission integrity. Considering the scope of our application this check has been disabled to keep the implementation simple and avoid any transmission overhead that may stem from this function. 
\item Data Size - The transmission width corresponding to the shift register has been selected as 8 bits with the MSB shifted out first. This corresponds to the standard SPI configuration practice. 
\end{itemize}

%-------------------------------------------------
\subsection{PWM Configuration for LED brightness}
The brightness of the LED display has been toggled using the technique of pulse width modulation (PWM). The PWM function works in close association with the hardware timers to generate the output pulses of adjustable width. Essentially a hardware timer is configured to count from 0 to a specified maximum value triggering some events in between. In the PWM mode the timer controls the output of 1 or more output channels. Once the timer output reaches 0, maximum or a specific compare value defined for each channel, the PWM output value of the channel can be changed. Various configuration options may be defined that affects how this output value is changed and on which event. The figure \ref{fig:pwm_timer} complements the above discussion.

\begin{figure}[!ht]
\centering
\includegraphics[scale = 0.8]{pwm_timer.PNG}
\textit{\caption{Interaction of PWM function with hardware timer}\label{fig:pwm_timer}}
\end{figure}

Initially the GPIO pins corresponding to the 4 LEDs are initialized as alternate-function connected to TIM4 peripheral with no defined active push-pull. Configuring PWM function first involves setting up the TIM4 hardware timer. Notably TIM4 has 4 output channels that are respectively connected to the 4 LEDs of our interest. TIM4 has been configured to count up with a period of 256 and default prescaler value defined. The default timer input clock frequency has been used and the repetition counter has been disabled for implementation simplicity. 

Following timer configuration, the output compare and PWM functions have been implemented for the respective channels. The output compare defines the active polarity of the generated pulse, which has been set to high in our application instance. The output pulse width is also defined by the output compare function that affects the active duty cycle of the PWM. 

The final demo version implements a toggle switch to increment the PWM pulse width (hence increasing the active duty cycle). Essentially duty cycle is incremented every time the a pushbutton click is registered on the master. The increment step size is defined by the master that communicates the value to the slave device over SPI once pushbutton click event has occurred. 

%-------------------------------------------------
\subsection{Revision and implementation of the final design}
Prior to the final demo, the Android application could not be successfully implemented to contain all the system components in the final design. In fact, some of the working components such as updating temperature and tilt angle values on the application side regressed. Consequently, acting upon advice imparted by the professor and the teaching assistants the implementation was revised to simply focus on the embedded devices. This new implementation is intended to highlight the most critical features of original intended specification, especially the SPI transmission, PWM function and the double tap feature. Given the revised specification, the following implementation rubric has been decided upon.

\begin{itemize}
\item The slave continually sends temperature and acceleometer readings to the master over SPI communication protocol.
\item The slave implements PWM logic to toggle brightness of display LEDs. %Specifically, the LED duty cycle is incremented using the pushbutton on the master. Once the duty cycle reaches maximum, it resets to minimium upon immediate pushbutton action and the functionality repeats.
\item Logic for double tap service implemented locally to register once a double tap action has occurred. 
\end{itemize}

A single threaded application has been implemented on the slave device for simplicity and ease of debugging. The thread continually updates the temperature and accelerometer readings and subsequently transmits to the master device. Since these readings are trivially transmitted, the corresponding SPI logic has been implemented in polling mode to ensure data is updated consistently. 3 bytes of data corresponding to roll, pitch and temperature values are continually transmitted from the slave device. Similar to the slave implementation, a single threaded implementation has been opted for on the master node to continually receive the sensor readings and subsequently display on the local serial debugger. 

PWM logic to toggle the duty cycle of the display LEDs has also been implemented on the slave device that can be triggered by events on the pushbutton on the master device and communicated via SPI protocol. A separate interrupt line has been leveraged to implement this synchronicity. Specifically once a pushbutton event has been registered the master raises an interrupt. Once the interrupt is registered on the slave device, it stops transmission of sensor readings and subsequently waits to receive data sent by the master. In our application instance, an arbitrary value has been initialized and subsequently incremented in steps of 5 and sent out to the slave device via SPI every time a pushbutton event has been registered. Subsequently this value is plugged in as the PWM pulse width on slave device to affect the active duty cycle. Given this SPI communication is largely interrupt-driven, the read-write functions on both the master and the slave have been implemented in the interrupt service routine (ISR). 

To extend the functionality of LED display beyond simply modulating the duty cycle, logic has been implemented to rotate the LEDs in either clockwise or counterclockwise orientation. By default the rotation order is clockwise. Everytime the pushbutton events have triggered duty cycle increments to 100\% it simply resets to minimum upon immediate trigger event and the functionality repeats. The rotation orientation changes subsequently, hence toggling between clockwise and counterclockwise orientation upon every PWM reset. 

Finally, logic has been implemented to register double tap event on the slave device. Once a double tap event has been registered, a simple message is printed in the local serial debugger to validate the action. 

%-------------------------------------------------
\subsection{SPI Testing}
The design and implementation of the SPI communication network has been accomplished incrementally with iterative testing and validation, hence requiring minimal revision when progressing through later development phases. The testing procedure mostly involved implementaion of different APIs (including the provided HAL and also custom defined) and validation using checks for data integrity on all the communication nodes. Occasionally the GPIO pins have been probed to verify the desired output waveform on the different transmission lines.

The first iteration of SPI implementation involved transmission of single byte of data from the master to the slave, and also receive the same data back to master as acknowledgement from the slave. This iteration implemented custom defined function that explicitly checked for the transmission-buffer-empty flag before selecting the desired device (selecting SS as 'LOW') and explicitly writing to the SPI data register. Once data transmission has completed the master sends dummy values to clock the bus such that the slave may send acknowledgement data. Once the master receives acknowledgement, it de-selects the device (select SS as 'HIGH') to signify the end of transmission. This implementation has been deemed successful as the data received by the slave corresponds to the data sent out and subsequently received by the master. The pseudocode for the custom implementation have been included in following.

\begin{algorithm}
\caption{Send and receive one byte to and from slave}\label{alg:read-write-master}
\begin{algorithmic}[1]
%\Procedure{SPI }{void}
\State if transmission buffer is empty
\State select SS
\State write data to SPI data register
\State write dummy bytes to SPI data register
\State read data from SPI data register
\State de-select SS
%\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Receive and send one byte from and to master}\label{alg:read-write-slave}
\begin{algorithmic}[1]
%\Procedure{SPI }{void}
\State if reception buffer is not empty
\State if select SS is true
\State read data from SPI data register
\State write data to SPI data register
%\EndProcedure
\end{algorithmic}
\end{algorithm}

The next iteration of SPI implementation involved transmission of single byte of data from the slave to the master. This iteration also implemented custom defined function. Since the master always initiates transmission, it first selects the intended slave and explicity transmits dummy values and subsequently receives the value in the SPI data register. The slave simply checks the GPIO pin for assertion of its select line and then writes the intended data to the data register. This implementation has also been deemed successful as the data sent by the slave has been verified to be equal to the data received by the master. The pseudocode for the custom implementation have been included in following.

\begin{algorithm}
\caption{Receive one byte from slave}\label{alg:single-byte-master}
\begin{algorithmic}[1]
%\Procedure{SPI }{void}
\State if transmission buffer is empty
\State select SS
\State write dummy bytes to SPI data register
\State read data from SPI data register
\State de-select SS
%\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Send one byte to master}\label{alg:single-byte-slave}
\begin{algorithmic}[1]
%\Procedure{SPI }{void}
\State if transmission buffer is empty
\State if select SS is true
\State write data to SPI data register
%\EndProcedure
\end{algorithmic}
\end{algorithm}

The final iteration involved transmission of multiple bytes of data using the previously defined APIs that have been tested and verified. Unfortunately the custom API failed for this case as the transmitted data was scrambled and inconsistent with the actual intended information. At this point the API for SPI transmission defined by HAL has been implementedon the slave. New custom read-write function has been implemented on the master that proved to be consistent through multiple transmission tests. The master defined three custom implementation for SPI transmission, notably for sending and receiving one byte, receiving multiple bytes and for sending multiple bytes. The pseudocode corresponding to the custom implementation have been included in following. This has been included in the final system design. The slave simply implements the HAL_SPI_Receive and HAL_SPI_Send for handling SPI transmission.

\begin{algorithm}
\caption{Send one byte from master}\label{alg:send-master}
\begin{algorithmic}[1]
\Procedure{SPI_SendByte}{byte}
\State if transmission buffer empty
\State write data to SPI data register
\State if reception buffer is not empty
\State read data from SPI data register
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Receive multiple bytes on master}\label{alg:receive-multiple-master}
\begin{algorithmic}[1]
\Procedure{SPI_Read}{buffer ptr, no. of bytes to read}
\State while no. of bytes > 0
\State buffer ptr = SPI_SendByte(DUMMY_BYTE)
\State no. of bytes to read--
\State buffer ptr++
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Send multiple bytes from master}\label{alg:send-multiple-master}
\begin{algorithmic}[1]
\Procedure{SPI_Write}{buffer ptr, no. of bytes to write}
\State while no. of bytes > 0
\State SPI_SendByte(buffer ptr)
\State no. of bytes to write--
\State buffer ptr++
\EndProcedure
\end{algorithmic}
\end{algorithm}